// fork_exec_wait.c
#include <unistd.h>     // fork, execlp, getpid, getppid
#include <sys/wait.h>   // waitpid
#include <stdio.h>      // printf, perror

int main() {
    pid_t pid = fork();
    if (pid < 0) { perror("fork"); return 1; }

    if (pid == 0) { // child
        printf("Child: pid=%d, ppid=%d\n", getpid(), getppid());
        execlp("ls", "ls", "-l", (char*)NULL); // replace child with 'ls -l'
        perror("execlp");                      // only if exec fails
        return 1;
    } else { // parent
        int status;
        printf("Parent: pid=%d, child=%d\n", getpid(), pid);
        if (waitpid(pid, &status, 0) == -1) { perror("waitpid"); return 1; }
        printf("Parent: child exited with status %d\n", status);
    }
    return 0;
}




// pipe_demo.c
#include <unistd.h>   // pipe, fork, read, write, close
#include <stdio.h>    // perror
#include <string.h>   // strlen

int main() {
    int fd[2];
    if (pipe(fd) == -1) { perror("pipe"); return 1; }

    pid_t pid = fork();
    if (pid < 0) { perror("fork"); return 1; }

    if (pid == 0) { // child: read end
        close(fd[1]); // close write end
        char buf[128];
        int n = read(fd[0], buf, sizeof(buf));
        if (n == -1) { perror("read"); return 1; }
        write(1, buf, n); // write to stdout
        close(fd[0]);
    } else { // parent: write end
        close(fd[0]); // close read end
        const char *msg = "Message through pipe from parent to child\n";
        if (write(fd[1], msg, (int)strlen(msg)) == -1) { perror("write"); return 1; }
        close(fd[1]);
    }
    return 0;
}



// file_io_syscalls.c
#include <fcntl.h>     // open, O_CREAT, O_WRONLY, etc.
#include <unistd.h>    // write, read, close, lseek
#include <stdio.h>     // perror
#include <string.h>    // strlen

int main() {
    int fd;
    const char *msg = "Hello from UNIX syscalls!\n";
    char buf[128];
    
    // create/truncate the file and write
    fd = open("demo.txt", O_CREAT | O_TRUNC | O_WRONLY, 0644);
    if (fd == -1) { perror("open for write"); return 1; }
    if (write(fd, msg, (int)strlen(msg)) == -1) { perror("write"); return 1; }
    close(fd);

    // open for read
    fd = open("demo.txt", O_RDONLY);
    if (fd == -1) { perror("open for read"); return 1; }

    // read and write to STDOUT (fd = 1)
    int n = read(fd, buf, sizeof(buf));
    if (n == -1) { perror("read"); return 1; }
    if (write(1, buf, n) == -1) { perror("write to stdout"); return 1; }

    close(fd);
    return 0;
}
